#!/usr/bin/perl

package peri_run; # to make PodWeaver happy

use 5.010;
use strict;
use warnings;

use Getopt::Long;
use Perinci::CmdLine;

# VERSION

my %opts = (
    library => [],
    subcommands => [],
);
Getopt::Long::Configure('pass_through', 'no_permute');
GetOptions(
    'library|I=s' => $opts{library},
    'help|h|?' => \$opts{help},
    'subcommand|s=s' => $opts{subcommands},
);

my $me = $0; $me =~ s!.+/!!;

my $oscs = $opts{subcommands};
if ($opts{help} || !@ARGV && !@$oscs) {
    print <<USAGE;
$me - Run a Perl module (or any package over Riap) on the command-line

Usage:

    $0 --help
    $0 [options] <module-URL-or-name> --list
    $0 [options] <module-URL-or-name> <func-name> [--help | [func-args]]
    $0 [options] -s <function-URL> ...

Options:

* --library (-I) _DIR_

Add a directory to Perl search dir (a la Perl's -I). Can be specified multiple
times.

* --subcommand (-s) _URL_

Instead of specifying a single module URL (and let $0 lists all functions in the
module as subcommand), specify each subcommand's URL. URL is URL to a Riap
function. Currently name of subcommand is automatically taken from last part of
URL path.

Examples:

    $0 Foo::Bar -l
    $0 http://example.org/api/Foo/Bar/ baz --yaml --arg 12
    $0 -s /Foo/Bar/func1 -s /Foo/Baz/func2 func1 --arg 12

Notes:

* module-URL-or-name is a Perl moule name ('Foo::Bar') or URL accepted by
  Perinci::Access (e.g. '/Foo/Bar/' or 'riap+tcp://localhost:5000/Foo/Bar/').

* This is currently a pretty minimal front-end. For more options, use
  Perinci::CmdLine directly.

Todo:

* HTTP authentication parameters

USAGE
    exit 0;
}

for my $dir (@{ $opts{library} }) { require lib; lib->import($dir) }

my $cmd = Perinci::CmdLine->new;

if (@ARGV && !@$oscs) {

    # module URL is specified. we expect another argument being the function
    # name, or else we add every function in the module as subcommand.

    my $module = shift @ARGV;
    my $func;
    if (defined($ARGV[0]) && $ARGV[0] =~ /\A\w+\z/) {
        $func = shift @ARGV;
    }

    if ($module =~ /\A\w+::(?:\w+)*\z/) {
        $module =~ s!::!/!;
        $module = "/$module/";
    }

    if ($func) {
        $cmd->url("$module$func");
    } else {
        $cmd->url("$module");
        my $pa = $cmd->{_pa};
        my $res = $pa->request(list => $module, {detail=>1});
        die "Can't request 'list' action on $module: $res->[0] - $res->[1]\n"
            unless $res->[0] == 200;
        my $scs = {};
        for my $e (@{$res->[2]}) {
            next unless $e->{type} eq 'function';
            my $sub = $e->{uri}; $sub =~ s!.+/!!;
            $scs->{$sub} = {
                url => $e->{uri},
                summary => $e->{summary},
            };
        }
        $cmd->subcommands($scs);
    }

} elsif (@$oscs) {

    # one or more subcommand URL is specified.

    my $scs = {};
    for my $url (@$oscs) {
        my $i = 1;
        my $leaf = $url; $leaf =~ s!.+/(.+)!$1!; $leaf ||= "func";
        my $name;
        while (1) {
            $name = $leaf . ($i > 1 ? $i : "");
            last unless $scs->{$name};
            $i++;
        }
        $scs->{$name} = {url => $url};
    }
    $cmd->subcommands($scs);

} else {

    die "BUG: This shouldn't be reached";

}

$cmd->run;

# ABSTRACT: Run Perl module (or any package over Riap) on the command-line

=head1 SYNOPSIS

From command-line:

 % peri-run Foo::Bar
 % peri-run http://example.com/api/Foo/Bar/

Or save this in C<foobar> somewhere in PATH:

 #!/bin/bash
 export PERI_RUN_PROGRAM_NAME=`basename $0`
 peri-run Foo::Bar

You can now do:

 % foobar --help; # show help

 % foobar --list; # list all subcommands, which are subroutines in Foo::Bar

 % foobar sub1 --arg1 ... --arg2 ...; # execute sub1

 % foobar --yaml sub1 ...; # execute sub1 and return output as YAML

 % foobar --help sub1; # show help usage for sub1

 % foobar --version

 % complete -C foobar foobar
 % foobar <TAB>; # tab completion will now work


=head1 DESCRIPTION

One of the lazy ways of writing a command-line application is by not writing it.
You just write your module functions, following a few conventions outlined in
L<Perinci::Access::InProcess>. Later you "export" your module as a command-line
application with B<peri-run> and get these features for free (among others):
options parsing, --help message, output formatting, and bash shell completion.

To make bash completion work, you need to execute the 'complete' command (shown
in Synopsis) first, either from your bash startup script (~/.bashrc,
/etc/bash.bashrc, etc).

Currently B<peri-run> offers only few options; it's just a quick way to run your
module. For more customization (e.g. only export some functions, rename
subcommands, run two or more modules, custom actions and behaviours via plugins,
etc), use Perinci::CmdLine directly.


=head1 SEE ALSO

L<Perinci::CmdLine>

=cut
